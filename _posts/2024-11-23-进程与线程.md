---
layout:     post
title:      "进程与线程"
date:       2024-11-23 00:00:00
author:     "lele"
header-img: "img/home-bg.jpg"
catalog: true
mathjax: true
tags:
    - 计算机操作系统
---
# 进程与线程
## 2.1进程与线程
- 进程包括三个部分:
  - 进程控制块PCB:创建进程的时候创建PCB,里边是进程的控制信息,操作系统通过这个来获取进程的信息
  - 程序部分
  - 数据部分<br>![text](/img/in-post/Snipaste_2024-11-24_11-25-37.png)
- 进程有5个状态:运行态,就绪态,阻塞态,创建态,终止态<br>前三个是基本状态<br>![](/img/in-post/Snipaste_2024-11-24_11-28-29.png)<br>一个进程从运行态变为阻塞态是主动的行为，而从阻塞态变为就绪态是被动的行为，需要其他相关进程的协助。
- 进程可以创建子进程,如果子进程删除,那么子进程的资源要归还父进程,如果父进程删除,子进程也要被删除
- 在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。
- **创建新进程的操作**:
  1. 给进程分配一个唯一的标识号,然后申请一个空白的PCB(PCB是有限的),申请不到就创建失败
  2. 给进程分配资源(这些资源是在PCB中体现的),如果资源不够,那也不算创建失败,而是处于创建态
  3. 初始化PCB,也就是初始化PCB包括的内容第二栏(进程控制和管理信息)
  4. 如果就绪队列还没满,那么这个进程就去排队,变为就绪态等待被调度
- **进程终止的操作**:
  1. 根据进程的PID、UID检测出这个进程的PCB，获取该进程的状态
  2. 然后终止该进程和子孙进程的运行
  3. 把该进程的资源归还给父进程或者是操作系统
  4. 然后把这个进程的PCB给删喽
- 进程之间的通信PV操作是低级通信，效率很低，高级通信有以下几种：
  1. **共享存储**：两个进程之间有个共有的内存空间，两个进程都可以通过PV操作对这段空间进行读写
  2. **消息传递**：两个进程之间没有公共的区域，通过发消息来进行通信，这种方式很能支持多CPU系统、分布式系统和计算机网络，所以用途的广
       - 直接通信方式 ：进程把消息发到对面的消息缓冲队列上边，对面的进程从队列上获取消息
       - 间接通信方式：把消息发给中间的实体（信箱），接受进程从信箱里边获取消息
  3. **管道通信**：管道是一个特殊的共享文件，数据在管道里边FIFO,管道两边只能各有一个进程，并且读的时候写进程阻塞，写的时候读进程阻塞<br>这种方式在Linux里边用的很多，Linux里管道文件为4KB，读写速度可能不匹配，当管道空的时候或者满的时候，谁快阻塞谁
   ![](/img/in-post/Snipaste_2024-11-24_11-57-13.png)
- 线程是轻量级的进程，在上下文切换的时候时空开销比较小，[线程就像是生产线，进程像工厂](https://www.doubao.com/thread/ab5fe96119646)，TCP（thread）线程控制块和PCB（process）很像，啥都像<br>线程是CPU调度的基本单位,可以独立执行程序
- [线程的实现](https://www.doubao.com/thread/a557406390af1)可以分为两类:**用户级线程**(User-Level Thread，ULT)和**内核级线程**(Kernel-Level Thread，KLT)。<br>
用户级线程是在用户视角下能看见的线程，操作系统不用干预，所以线程之间的切换不用转换到内核态，开销很小<br>
**用户级线程就像是民间组织**，可以非常灵活解决不用内核操心的问题，但是涉及内核的问题（I\O等）就需要和内核商榷，开销大<br>
**内核级线程就像是官方机构**，行为调度极为严整，相对重量级，虽然做事效率高，但是消耗大
- [多线程模型](https://www.doubao.com/thread/abcc237f909df)：
  - **一对一模型**：每个民间组织对应一个具体的官方负责人，行为调度非常明确，这个民间组织工作受阻也不影响其他活动，但是因为这个组织啥都让负责人负责，所以开销大
    >优点:当一个线程被阻塞后，允许调度另一个线程运行，所以并发能力较强。<br>缺点:每创建一个用户线程，相应地就需要创建一个内核线程，开销较大。
  - **一对多模型**：一个官方负责人管了好几个组织，遇到的问题可以在内部讨论解决，效率高，但是有一个组织遇到问题，整个组织就就会受到影响
    >优点:线程管理是在用户空间进行的，无须切换到核心态，因而效率比较高。<br>缺点:如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞;在任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个CPU上运行。
  - **多对多模型**：有前两个的优点
- 单处理器中如果有10个进程，可能会有下边几种情况：
   - 一个处于运行态，其余九个处于阻塞态或者就绪态
   - 10个进程全部阻塞
   - 就算10个进程并发执行，也是一个运行九个就绪
- C语言编写的程序在使用内存时一般分为三个段，它们一般是**正文段**(代码和赋值数据段)、**数据堆段**和**数据栈段**。<br>**二进制代码和常量存放在正文段，动态分配的存储区在数据堆段，临时使用的变量在数据栈段。**<br>由此，我们可以确定全局赋值变量在正文段赋值数据段，未赋值的局部变量和实参传递在栈段，动态内存分配在堆段，常量在正文段，进程的优先级只能在 PCB内。
- 在同一进程中，线程的切换不会引起进程的切换。当从一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换。
- [线程可以节省系统资源](https://www.doubao.com/thread/a1ab29322ff04)，但线程并不能增强进程安全性，因为线程共享进程的地址空间和资源，若一个线程出错，则可能影响整个进程的运行。
- CPU调度以线程为单位,在多处理器中,内核级线程的调度是并行的,用户级线程不行,因为操作系统只能看到进程这一级。
- 从阻塞变为执行才叫唤醒，从就绪变为执行不叫唤醒。
## 2.2CPU调度
- 三种调度：
  - 高级调度：作业调度，把作业从外存调入内存。
  - 中级调度：把内存中暂时不用的进程调到外存中（挂起态）。
  - 低级调度：进程调度，决定哪个进程获得CPU，发生频率很高，一般几十毫秒一次
- 进行CPU调度的事件：
  - 创建新进程：父进程和子进程都处于就绪态，操作系统需要决定运行哪个。
  - 进程结束或者被终止，操作系统从就绪队列中选择一个进程运行，没有的话就运行闲逛进程
  - 进程被阻塞之后要选择别的进程运行
  - 被阻塞的进程所要的条件被满足之后CPU会决定运行这个进程还是接着运行现在的进程
- 不能进行调度的情况：
  - 在中断处理的时候，这个中断处理程序属于系统的操作，不属于某个进程所以不能进行调度
  - 在执行原子操作的时候
- 用户级线程和内核级线程的调度：
  - 操作系统不知道有用户级线程的存在，所以操作系统还是跟以前一样选择一个进程发放时间片运行，由进程自己决定运行哪一个线程
  - 操作系统会选择一个线程，不考虑这个线程属于哪一个进程，就分配时间片之后运行
- 上下文切换的流程：
  - 把CPU的信息保存到进程的PCB中，里边有程序计数器和其他寄存器
  - 把这个进程的PCB移入就绪或者阻塞队列
  - 选择另一个进程读取它的PCB
  - 恢复新进程的上下文
  - 跳转到新进程PCB里边PC指向的位置执行
- CPU调度的算法：
  - 先来先服务，效果很不好，因为有利于CPU繁忙型，不利于I\O繁忙型，因为CPU繁忙的作业计算完就走了，I\O繁忙的作业还要等可长时候才开始计算
  - 短作业优先，要是一直有短作业来，那长作业要饿死
  - 高相应比优先：$相应比=\frac{等待时间+要求服务时间}{要求服务时间}$
  - 优先级调度：
    - 系统进程>用户进程；
    - 交互型进程（前台进程）>非交互型进程（后台进程）
    - I\O型进程>计算型进程，因为I\O很慢，所以要先启动设备
  - 时间片轮转调度
  - 多级队列调度算法：把不同的作业分为不同的队列，不同的队列中采用不同的调度算法
  - 
  