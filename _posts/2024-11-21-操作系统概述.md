---
layout:     post
title:      "操作系统概述"
date:       2024-11-21 00:00:00
author:     "lele"
header-img: "img/home-bg.jpg"
catalog: true
mathjax: true
tags:
    - 计算机操作系统
---
# 操作系统概述
## 1.1操作系统的基本概念
- 操作系统的四大特征:并发,共享,虚拟,异步,前两个是最基本的特征;<br>
**并发**是指两个或多个事件在同一时间间隔内发生;<br>
**共享**是指系统中的资源可供内存中多个并发执行的进程共同使用;<br>
**虚拟**是指将一个物理上的实体变为若干逻辑上的对应物;<br>
**异步**是指计算机中的进程因为资源问题,所以不是一下就运行到底的而是走走停停
- 操作系统提供的接口主要分为两类:一类是**命令接口**，用户利用这些操作命令来组织和控制作业的执行:另一类是**程序接口**，编程人员可以使用它们来请求操作系统服务。<br>
命令接口有联机和脱机两种:联机是输入一条命令就要得到结果,就是交互性;脱机是把处理任务直接扔给计算机,用户不干预计算机的运行,坐等结果;<br>
程序接口是由一组系统调用组成,GUI就是通过调用程序接口实现的,但是GUI不是操作系统的一部分,GUI调用的系统调用命令是操作系统的一部分;
## 1.2操作系统发展历程
- **单道批处理系统**:把一堆作业扔给操作系统,配上监督程序,作业一个一个进行,具有自动性,顺序性,单道性;
- **多道批处理系统**用户所提交的作业都先存放在外存上并排成一个队列，作业调度程序按一定的算法从后备队列中选择若干作业调入内存，它们在管理程序的控制下相互穿插地运行
- **分时操作系统**是指将处理器的运行时间分成很短的时间片，按时间片轮流将处理器分配给各个作业<br>多个用户终端共享主机,响应时间很短,但是对于需要实时反馈的作业就不够了,需要实时系统
- **实时系统**有硬实时和软实时,前者对于时间要求很严格,后者拖延一会也没事
- 多道程序技术要求进程间能实现并发，需要实现进程调度以保证CPU的工作效率，而并发性的实现需要中断功能的支持。
## 1.3操作系统的运行环境
- CPU 的运行模式划分为用户态(目态)和核心态(又称管态、内核态)。
- 特权指令(核心态)，是指不允许用户直接使用的指令，如I/O 指令、关中断指令、内存清零指令,存取用于内存保护的寄存器、送 PSW 到程序状态字寄存器等的指令。<br>非特权指令(用户态)，是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，这也是为了防止用户程序对系统造成破坏。
- **中断和异常**:<br>![](/img/in-post/Snipaste_2024-11-21_20-21-35.png)
- **系统调用的功能**:<br>
设备管理。完成设备的请求或释放，以及设备启动等功能。<br>
文件管理。完成文件的读、写、创建及删除等功能。<br>
进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。<br>
进程通信。完成进程之间的消息传递或信号传递等功能。<br>
内存管理。完成内存的分配、回收以及获取作业占用内存区大小和起始地址等功能。
- 用户程序创建一个新进程，需使用操作系统提供的系统调用接口<br>
用户程序使用系统调用命令，该命令经过编译后形成若干参数和陷入指令<br>当操作系统完成用户请求的系统调用功能后，应使CPU从内核态转到用户态
- 在中断发生后，进入中断处理的程序只能属于操作系统程序
- 计算机通过**硬件**完成操作系统由用户态到核心态的转换，这是通过中断机制来实现的。发生中断事件时，由硬件中断机制将计算机状态置为核心态。
- 大多数计算机操作系统的内核包括四个方面的内容，即时钟管理、中断机制、原语和系统控制的数据结构及处理，其中第4部分实际上是系统调用类的指令(广义指令)。<br>
  > 置时钟指令是在核心态运行的,如果该指令允许在用户态执行，那么程序就可以自行更改时间片，会一直霸占CPU。
- 命令解释程序属于命令接口，能面对用户，在用户态下执行。磁盘调度程序、中断处理程序和进程调度程序都工作在内核态。
- “访管”指令仅在用户态下使用，**执行“访管”指令将用户态转变为核心态。**
- 系统调用命令工作在核心态，系统调用本身是一条在核心态运行的命令，并不是调用系统的命令，调用系统调用的命令才是用户态的。<br>**也就是说，系统调用的发生是在用户态，系统调用的执行是在核心态**
- I/O设备的请求、时钟中断是外部中断。<br>
  访管指令、缺页异常是内部中断。
- 系统调用需要保存 PSW 和PC的值，一般过程调用只需保存PC的值。<br>![](/img/in-post/Snipaste_2024-11-23_08-53-49.png)<br>一般过程调用的被调用程序与调用程序运行在同一个状态，可能是系统态，也可能是用户态<br>系统调用的被调用过程一定运行在核心态
- trap 指令、跳转指令和压栈指令均可以在用户态执行，其中 trap 指令负责由用户态转换为内核态。关中断指令为特权指令，必须在核心态才能执行。**注意**，在操作系统中，关中断指令是权限非常大的指令，因为中断是现代操作系统正常运行的核心保障之一，能把它关掉，说明执行这条指令的一定是权限非常大的机构(管态)。
- 外部中断处理过程，PC 值由中断隐指令自动保存，而通用寄存器内容由操作系统保存。块表(TLB)和 Cache 中的内容则由硬件机构保存。
- 执行系统调用的过程：<br>
  1. 传递系统调用参数
  2. 执行陷入(trap)指令
  3. 执行相应的服务程序
  4. 返回用户态
- 当 CPU 检测到中断信号后，由硬件自动保存被中断程序的断点\[程序计数器(PC)和程序状态字寄存器(PSW)\]
  >麻蛋，到底是硬件保存的还是中断隐指令保存的啊，**暂定是硬件保存的**

  之后，硬件找到该中断信号对应的中断向量，中断向量指明中断服务程序入口地址(各中断向量统一存放在中断向量表中，该表由操作系统初始化)。<br>接下来开始执行中断服务程序，保存中断屏蔽字、保存各通用寄存器的值，并提供与中断信号对应的中断服务
- **系统调用是由用户进程发起的，请求操作系统的服务。**<br>
  1. 当内存中的空闲页框不够时，操作系统会将某些页面调出，并将要访问的页面调入，这个过程完全由操作系统完成，不涉及系统调用。
  2.  进程调度完全由操作系统完成，无法通过系统调用完成。
  3. 创建新进程可以通过系统调用来完成，如Linux 中通过 fork 系统调用来创建子进程。
- 发生系统调用时，CPU 通过执行软中断指令将CPU的运行状态从用户态切换到内核态，这个过程与中断和异常的响应过程相同,，**由硬件负责保存断点和程序状态字,并将 CPU 模式改为内核态**。<br>然后，执行操作系统内核的系统调用入口程序，**该内核程序负责保存通用寄存器的内容，再调用执行特定的系统调用服务例程。**<br>综上，前俩由硬件完成，后俩由操作系统完成。
## 1.4操作系统的结构，引导和虚拟机
- 结构：<br>
  1. **分层法**：把操作系统分层，从底层（硬件）一层层向上扩充，每层只能调用紧邻它的低层的功能和服务(单向依赖)。
     - **优势**：容易调试检查错误，一层一层向上检查，很容易确定具体哪一层出错；<br>容易扩充和维护，跟砌墙一样，想实现更高的功能只需要一层层叠加就🆗了
     - **劣势**：合理定义各层比较困难，各层之间挨得太近，暧昧不分；<br>效率很差，要完成某个功能要从底层开始穿越
  2. **模块化**：把操作系统按照不同的功能分为不同的模块
     - **优势**：①提高了操作系统设计的正确性、可理解性和可维护性;②增强了操作系统的可适应性;③加速了操作系统的开发过程。
     - **劣势**：接口很难设计，你不知道它都有啥需求；<br>模块也很难设计，各个模块要齐头并进，顺序很难把握；
  3. [微内核](https://www.doubao.com/thread/a4197fa860ae6)是保留最基础的内核功能，把多余的功能都剥离出去。<br>
     - 优势：
       1. 扩展性和灵活性。
       2. 可靠性和安全性。
       3. 可移植性
       4. 分布式计算。
     - 劣势：有点性能问题，因为需要频繁地在用户态和内核态之间切换
  4. **宏内核**：把所有功能都聚合到一起，效率很高，共享信息很快，但是操作系统越做越大，这种结构就很臃肿
- 模块化操作系统的各功能模块都在内核中，且模块之间相互调用、相互依赖，任何一个模块出错，都可能导致整个内核崩溃。<br>在微内核操作系统中，内核外的某个功能模块出错不会导致整个系统崩溃，可靠性高。 
- 操作系统的启动过程：![text](/img/in-post/Snipaste_2024-11-23_09-40-56.png)
- Windows 是融合了宏内核和微内核的操作系统
- 在拥有外核的操作系统中，外核只负责硬件资源的分配、回收、保护等，进程管理相关的工作仍然由内核负责。
- 引导程序有两种，一种是位于BIOS中的用于引导开启各个设备，一种是位于硬盘中的用于引导操作系统
- 第一类虚拟机管理程序直接运行在物理硬件之上，具有高性能和高安全性；第二类虚拟机管理程序运行在现有操作系统之上，安装和使用相对简单。[详细](https://www.doubao.com/thread/a3ff2039790f2)
- BIOS 将控制权交给排在首位的启动设备后，CPU 将该设备主引导扇区的内容\[主引导记录(MBR)\]加载到内存中，然后由 MBR 检查分区表，查找活动分区，并将该分区的引导扇区的内容\[分区引导记录(PBR)\]加载到内存加以执行。
- **访管指令与访管中断**：![text](/img/in-post/Snipaste_2024-11-23_10-42-53.png)