---
layout:     post
title:      "内存管理"
date:       2024-12-7 00:00:00
author:     "lele"
header-img: "img/home-bg.jpg"
catalog: true
mathjax: true
tags:
    - 计算机操作系统
---
# 内存管理的基本概念
- 内存管理的功能:
  - 内存空间的分配与回收
  - 内存转换:从逻辑地址到物理地址的转换
  - 内存扩展:虚拟存储,把外存当做内存用
  - 内存保护:进程只在自己的领域活动,不跑到别的进程的地址空间
    > 有两种方法：
    > 1. 在CPU中设置一对儿上下限寄存器，访问的时候直接和这俩值相比
    > 2. 用基地址（基地址寄存器）和偏移量（界地址寄存器）这种方法
  - 内存共享:让多个进程访问同一内存段,实现进程的通信
- 编译、链接、装入：
  - 编译是把源代码变成目标语言，这种语言可能是机器语言或者是某种中间表示形式
  - 链接是把目标文件和库文件连在一起，生成可执行文件
  - 装入是由装入程序把可执行文件装入内存
    >装入有三种方式：
    >1. 绝对装入：逻辑地址就是物理地址，程序直接放到内存
    >2. 可重定位装入：程序的地址从0开始，所有地址相当于偏移量，装入的时候修改基地址就好
    >3. 动态运行时装入：先把这个程序装入内存，直到程序执行的时候才变换地址，这种方式可以动态申请内存，还可以不连续存放
- 连续分配管理方式：
  - 单一连续分配：把内存划分为用户区和系统区，用户区就一个用户程序，最垃圾，只适合单任务，单用户的操作系统使用，内存利用率也超级低
  - 固定分区分配：把内存划分为固定的分区供程序装入
    - 分区相等：没有灵活性，程序太大无法装入，程序太小碎片老多
    - 分区不等：多个小分区，适量中分区，一点大分区
  - 动态分区分配：来一个程序排一个程序，中间有程序撤退的时候，把来的程序看情况塞到中间的空挡里；这种方法用的时间长的话内部碎片会越来越多<br>回收的时候有四种情况：
     1. 回收区的前边是空闲分区，合并的时候修改前一个分区表项的大小即可
     2. 回收区的后边是空闲分区，合并的时候修改后一个分区表项的始址和大小
     3. 回收区的前边和后边都是空闲分区，合并的时候取消后一个分区的表项，修改前一个分区的大小
     4. 回收区前后都没有空闲分区，为这个分区新建一个表项，把这个表项插入到空闲分区链中
- 动态分区算法：
  - 首次适应算法（first fit）：把地址从小到大开始排，从头开始找适合的分区
  - 邻近适应算法（next fit）：在first fit的基础上，从上一个结束查找的位置开始查找，也就是循环查找，通常比first fit的性能更差
  - 最佳适应算法（best fit）：把容量从小到大开始排，从头开始找到合适的分区
  - 最坏适应算法（worst fit）：把容量从大到小开始排，从头开始找到合适的分区