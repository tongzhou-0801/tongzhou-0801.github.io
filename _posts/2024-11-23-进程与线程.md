---
layout:     post
title:      "进程与线程"
date:       2024-11-23 00:00:00
author:     "lele"
header-img: "img/home-bg.jpg"
catalog: true
mathjax: true
tags:
    - 计算机操作系统
---
# 进程与线程
## 2.1进程与线程
- 进程包括三个部分:
  - 进程控制块PCB:创建进程的时候创建PCB,里边是进程的控制信息,操作系统通过这个来获取进程的信息
  - 程序部分
  - 数据部分<br>![text](/img/in-post/Snipaste_2024-11-24_11-25-37.png)
- 进程有5个状态:运行态,就绪态,阻塞态,创建态,终止态<br>前三个是基本状态<br>![](/img/in-post/Snipaste_2024-11-24_11-28-29.png)<br>一个进程从运行态变为阻塞态是主动的行为，而从阻塞态变为就绪态是被动的行为，需要其他相关进程的协助。
- 进程可以创建子进程,如果子进程删除,那么子进程的资源要归还父进程,如果父进程删除,子进程也要被删除
- 在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。
- **创建新进程的操作**:
  1. 给进程分配一个唯一的标识号,然后申请一个空白的PCB(PCB是有限的),申请不到就创建失败
  2. 给进程分配资源(这些资源是在PCB中体现的),如果资源不够,那也不算创建失败,而是处于创建态
  3. 初始化PCB,也就是初始化PCB包括的内容第二栏(进程控制和管理信息)
  4. 如果就绪队列还没满,那么这个进程就去排队,变为就绪态等待被调度
- **进程终止的操作**:
  1. 根据进程的PID、UID检测出这个进程的PCB，获取该进程的状态
  2. 然后终止该进程和子孙进程的运行
  3. 把该进程的资源归还给父进程或者是操作系统
  4. 然后把这个进程的PCB给删喽
- 进程之间的通信PV操作是低级通信，效率很低，高级通信有以下几种：
  1. **共享存储**：两个进程之间有个共有的内存空间，两个进程都可以通过PV操作对这段空间进行读写
  2. **消息传递**：两个进程之间没有公共的区域，通过发消息来进行通信，这种方式很能支持多CPU系统、分布式系统和计算机网络，所以用途的广
       - 直接通信方式 ：进程把消息发到对面的消息缓冲队列上边，对面的进程从队列上获取消息
       - 间接通信方式：把消息发给中间的实体（信箱），接受进程从信箱里边获取消息
  3. **管道通信**：管道是一个特殊的共享文件，数据在管道里边FIFO,管道两边只能各有一个进程，并且读的时候写进程阻塞，写的时候读进程阻塞<br>这种方式在Linux里边用的很多，Linux里管道文件为4KB，读写速度可能不匹配，当管道空的时候或者满的时候，谁快阻塞谁
   ![](/img/in-post/Snipaste_2024-11-24_11-57-13.png)
- 线程是轻量级的进程，在上下文切换的时候时空开销比较小，[线程就像是生产线，进程像工厂](https://www.doubao.com/thread/ab5fe96119646)，TCP（thread）线程控制块和PCB（process）很像，啥都像<br>线程是CPU调度的基本单位,可以独立执行程序
- [线程的实现](https://www.doubao.com/thread/a557406390af1)可以分为两类:**用户级线程**(User-Level Thread，ULT)和**内核级线程**(Kernel-Level Thread，KLT)。<br>
用户级线程是在用户视角下能看见的线程，操作系统不用干预，所以线程之间的切换不用转换到内核态，开销很小<br>
**用户级线程就像是民间组织**，可以非常灵活解决不用内核操心的问题，但是涉及内核的问题（I\O等）就需要和内核商榷，开销大<br>
**内核级线程就像是官方机构**，行为调度极为严整，相对重量级，虽然做事效率高，但是消耗大
- [多线程模型](https://www.doubao.com/thread/abcc237f909df)：
  - **一对一模型**：每个民间组织对应一个具体的官方负责人，行为调度非常明确，这个民间组织工作受阻也不影响其他活动，但是因为这个组织啥都让负责人负责，所以开销大
    >优点:当一个线程被阻塞后，允许调度另一个线程运行，所以并发能力较强。<br>缺点:每创建一个用户线程，相应地就需要创建一个内核线程，开销较大。
  - **一对多模型**：一个官方负责人管了好几个组织，遇到的问题可以在内部讨论解决，效率高，但是有一个组织遇到问题，整个组织就就会受到影响
    >优点:线程管理是在用户空间进行的，无须切换到核心态，因而效率比较高。<br>缺点:如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞;在任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个CPU上运行。
  - **多对多模型**：有前两个的优点